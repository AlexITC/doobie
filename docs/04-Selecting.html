<html><head><title>doobie: Selecting Data</title><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Rob Norris" /><meta name="description" content="A functional JDBC layer for Scala." /><meta name="og:image" content="/doobie/img/poster.png" /><meta name="image" property="og:image" content="/doobie/img/poster.png" /><meta name="og:title" content="doobie: Selecting Data" /><meta name="title" property="og:title" content="doobie: Selecting Data" /><meta name="og:site_name" content="doobie" /><meta name="og:url" content="" /><meta name="og:type" content="website" /><meta name="og:description" content="A functional JDBC layer for Scala." /><link rel="icon" type="image/png" href="/doobie/img/favicon.png" /><meta name="twitter:title" content="doobie: Selecting Data" /><meta name="twitter:image" content="/doobie/img/poster.png" /><meta name="twitter:description" content="A functional JDBC layer for Scala." /><meta name="twitter:card" content="summary_large_image" /><link rel="icon" type="image/png" sizes="16x16" href="/doobie/img/favicon16x16.png" /><link rel="icon" type="image/png" sizes="24x24" href="/doobie/img/favicon24x24.png" /><link rel="icon" type="image/png" sizes="32x32" href="/doobie/img/favicon32x32.png" /><link rel="icon" type="image/png" sizes="48x48" href="/doobie/img/favicon48x48.png" /><link rel="icon" type="image/png" sizes="57x57" href="/doobie/img/favicon57x57.png" /><link rel="icon" type="image/png" sizes="60x60" href="/doobie/img/favicon60x60.png" /><link rel="icon" type="image/png" sizes="64x64" href="/doobie/img/favicon64x64.png" /><link rel="icon" type="image/png" sizes="70x70" href="/doobie/img/favicon70x70.png" /><link rel="icon" type="image/png" sizes="72x72" href="/doobie/img/favicon72x72.png" /><link rel="icon" type="image/png" sizes="76x76" href="/doobie/img/favicon76x76.png" /><link rel="icon" type="image/png" sizes="96x96" href="/doobie/img/favicon96x96.png" /><link rel="icon" type="image/png" sizes="114x114" href="/doobie/img/favicon114x114.png" /><link rel="icon" type="image/png" sizes="120x120" href="/doobie/img/favicon120x120.png" /><link rel="icon" type="image/png" sizes="128x128" href="/doobie/img/favicon128x128.png" /><link rel="icon" type="image/png" sizes="144x144" href="/doobie/img/favicon144x144.png" /><link rel="icon" type="image/png" sizes="150x150" href="/doobie/img/favicon150x150.png" /><link rel="icon" type="image/png" sizes="152x152" href="/doobie/img/favicon152x152.png" /><link rel="icon" type="image/png" sizes="196x196" href="/doobie/img/favicon196x196.png" /><link rel="icon" type="image/png" sizes="310x310" href="/doobie/img/favicon310x310.png" /><link rel="icon" type="image/png" sizes="310x150" href="/doobie/img/favicon310x150.png" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/doobie/highlight/styles/color-brewer.css" /><link rel="stylesheet" href="/doobie/css/style.css" /><link rel="stylesheet" href="/doobie/css/palette.css" /><link rel="stylesheet" href="/doobie/css/codemirror.css" /><link rel="stylesheet" href="/doobie/css/tweak.css" /></head><body class="docs"><div id="wrapper"><div id="sidebar-wrapper"><ul id="sidebar" class="sidebar-nav"><li class="sidebar-brand"><a href="/doobie/" class="brand"><div class="brand-wrapper"><span>doobie</span></div></a></li><li><a href="/doobie/css/style.css" class=""></a></li><li><a href="/doobie/docs/02-Toolkit.html" class="">Toolkit</a></li><li><a href="/doobie/docs/03-Connecting.html" class="">Connecting to a Database</a></li><li><a href="/doobie/docs/04-Selecting.html" class=" active ">Selecting Data</a></li><li><a href="/doobie/docs/05-Parameterized.html" class="">Parameterized Queries</a></li><li><a href="/doobie/docs/06-Checking.html" class="">Typechecking Queries</a></li><li><a href="/doobie/docs/07-Updating.html" class="">DDL, Inserting, and Updating</a></li><li><a href="/doobie/docs/08-Fragments.html" class="">Statement Fragments</a></li><li><a href="/doobie/docs/09-Error-Handling.html" class="">Error Handling</a></li><li><a href="/doobie/docs/10-Logging.html" class="">Logging</a></li><li><a href="/doobie/docs/11-Arrays.html" class="">SQL Arrays</a></li><li><a href="/doobie/docs/12-Custom-Mappings.html" class="">Custom Mappings</a></li><li><a href="/doobie/docs/13-Unit-Testing.html" class="">Unit Testing</a></li><li><a href="/doobie/docs/14-Managing-Connections.html" class="">Managing Connections</a></li><li><a href="/doobie/docs/15-Extensions-PostgreSQL.html" class="">Extensions for PostgreSQL</a></li><li><a href="/doobie/docs/16-Extensions-H2.html" class="">Extensions for H2</a></li><li><a href="/doobie/docs/17-Quill.html" class="">Quill Integration</a></li><li><a href="/doobie/docs/18-FAQ.html" class="">Frequently-Asked Questions</a></li><li><a href="/doobie/" class=""></a></li><li><a href="/doobie/css/palette.css" class=""></a></li><li><a href="/doobie/docs/01-Introduction.html" class="">Introduction</a></li></ul></div><div id="page-content-wrapper"><div class="nav"><div class="container-fluid"><div class="row"><div class="col-lg-12"><div class="action-menu pull-left clearfix"><a href="#menu-toggle" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a></div><ul class="pull-right"><li id="gh-eyes-item" class="hidden-xs"><a href="https://github.com/tpolecat/doobie"><i class="fa fa-eye"></i><span>WATCH<span id="eyes" class="label label-default">--</span></span></a></li><li id="gh-stars-item" class="hidden-xs"><a href="https://github.com/tpolecat/doobie"><i class="fa fa-star-o"></i><span>STARS<span id="stars" class="label label-default">--</span></span></a></li><li><a href="#" onclick="shareSiteTwitter('doobie A functional JDBC layer for Scala.');"><i class="fa fa-twitter"></i></a></li><li><a href="#" onclick="shareSiteFacebook('doobie A functional JDBC layer for Scala.');"><i class="fa fa-facebook"></i></a></li><li><a href="#" onclick="shareSiteGoogle();"><i class="fa fa-google-plus"></i></a></li></ul></div></div></div></div><div id="content" data-github-owner="tpolecat" data-github-repo="doobie"><div class="content-wrapper"><section><h2 id="selecting-data">Selecting Data</h2>

<p>In this chapter will write some some programs to read from the database, mapping rows to Scala types on the way. We also introduce YOLO mode for experimenting with <strong>doobie</strong> in the REPL.</p>

<h3 id="setting-up">Setting Up</h3>

<p>First let’s get our imports out of the way and set up a <code class="highlighter-rouge">Transactor</code> as we did before. You can skip this step if you still have your REPL running from last chapter.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">doobie._</span>
<span class="k">import</span> <span class="nn">doobie.implicits._</span>
<span class="k">import</span> <span class="nn">doobie.util.ExecutionContexts</span>
<span class="k">import</span> <span class="nn">cats._</span>
<span class="k">import</span> <span class="nn">cats.data._</span>
<span class="k">import</span> <span class="nn">cats.effect._</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>
<span class="k">import</span> <span class="nn">fs2.Stream</span>

<span class="c1">// We need a ContextShift[IO] before we can construct a Transactor[IO]. The passed ExecutionContext
// is where nonblocking operations will be executed. For testing here we're using a synchronous EC.
</span><span class="k">implicit</span> <span class="k">val</span> <span class="n">cs</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">.</span><span class="n">contextShift</span><span class="o">(</span><span class="nc">ExecutionContexts</span><span class="o">.</span><span class="n">synchronous</span><span class="o">)</span>

<span class="c1">// A transactor that gets connections from java.sql.DriverManager and executes blocking operations
// on an our synchronous EC. See the chapter on connection handling for more info.
</span><span class="k">val</span> <span class="n">xa</span> <span class="k">=</span> <span class="nc">Transactor</span><span class="o">.</span><span class="n">fromDriverManager</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span>
  <span class="s">"org.postgresql.Driver"</span><span class="o">,</span>     <span class="c1">// driver classname
</span>  <span class="s">"jdbc:postgresql:world"</span><span class="o">,</span>     <span class="c1">// connect URL (driver-specific)
</span>  <span class="s">"postgres"</span><span class="o">,</span>                  <span class="c1">// user
</span>  <span class="s">""</span><span class="o">,</span>                          <span class="c1">// password
</span>  <span class="nc">Blocker</span><span class="o">.</span><span class="n">liftExecutionContext</span><span class="o">(</span><span class="nc">ExecutionContexts</span><span class="o">.</span><span class="n">synchronous</span><span class="o">)</span> <span class="c1">// just for testing
</span><span class="o">)</span>
</code></pre>
</div>

<p>We will be playing with the <code class="highlighter-rouge">country</code> table, shown here for reference. If you don’t have the <code class="highlighter-rouge">world</code> database set up, go back to the <a href="01-Introduction.html">Introduction</a> for instructions.</p>

<div class="language-sql highlighter-rouge"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">country</span> <span class="p">(</span>
  <span class="n">code</span>       <span class="n">character</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">name</span>       <span class="n">text</span>          <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">population</span> <span class="n">integer</span>       <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">gnp</span>        <span class="n">numeric</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
  <span class="c1">-- more columns, but we won't use them here</span>
<span class="p">)</span>
</code></pre>
</div>

<h3 id="reading-rows-into-collections">Reading Rows into Collections</h3>

<p>For our first query let’s aim low and select some country names into a <code class="highlighter-rouge">List</code>, then print out the first few. There are several steps here so we have noted the types along the way.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="n">sql</span><span class="s">"select name from country"</span>
  <span class="o">.</span><span class="n">query</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>    <span class="c1">// Query0[String]
</span>  <span class="o">.</span><span class="n">to</span><span class="o">[</span><span class="kt">List</span><span class="o">]</span>         <span class="c1">// ConnectionIO[List[String]]
</span>  <span class="o">.</span><span class="n">transact</span><span class="o">(</span><span class="n">xa</span><span class="o">)</span>     <span class="c1">// IO[List[String]]
</span>  <span class="o">.</span><span class="n">unsafeRunSync</span>    <span class="c1">// List[String]
</span>  <span class="o">.</span><span class="n">take</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>          <span class="c1">// List[String]
</span>  <span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span> <span class="c1">// Unit
// Afghanistan
// Netherlands
// Netherlands Antilles
// Albania
// Algeria
</span></code></pre>
</div>

<p>Let’s break this down a bit.</p>

<ul>
  <li><code class="highlighter-rouge">sql"select name from country".query[String]</code> defines a <code class="highlighter-rouge">Query0[String]</code>, which is a one-column query that maps each returned row to a <code class="highlighter-rouge">String</code>. We will get to more interesting row types soon.</li>
  <li><code class="highlighter-rouge">.to[List]</code> is a convenience method that accumulates rows into a <code class="highlighter-rouge">List</code>, in this case yielding a <code class="highlighter-rouge">ConnectionIO[List[String]]</code>. It works with any collection type that has a <code class="highlighter-rouge">CanBuildFrom</code>. Similar methods are:
    <ul>
      <li><code class="highlighter-rouge">.unique</code> which returns a single value, raising an exception if there is not exactly one row returned.</li>
      <li><code class="highlighter-rouge">.option</code> which returns an <code class="highlighter-rouge">Option</code>, raising an exception if there is more than one row returned.</li>
      <li><code class="highlighter-rouge">.nel</code> which returns an <code class="highlighter-rouge">NonEmptyList</code>, raising an exception if there are no rows returned.</li>
      <li>See the Scaladoc for <code class="highlighter-rouge">Query0</code> for more information on these and other methods.</li>
    </ul>
  </li>
  <li>The rest is familar; <code class="highlighter-rouge">transact(xa)</code> yields a <code class="highlighter-rouge">IO[List[String]]</code> which we run, giving us a normal Scala <code class="highlighter-rouge">List[String]</code> that we print out.</li>
</ul>

<h3 id="internal-streaming">Internal Streaming</h3>

<p>The example above is ok, but there’s not much point reading all the results from the database when we only want the first five rows. So let’s try a different approach.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="n">sql</span><span class="s">"select name from country"</span>
  <span class="o">.</span><span class="n">query</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>    <span class="c1">// Query0[String]
</span>  <span class="o">.</span><span class="n">stream</span>           <span class="c1">// Stream[ConnectionIO, String]
</span>  <span class="o">.</span><span class="n">take</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>          <span class="c1">// Stream[ConnectionIO, String]
</span>  <span class="o">.</span><span class="n">compile</span><span class="o">.</span><span class="n">toList</span>   <span class="c1">// ConnectionIO[List[String]]
</span>  <span class="o">.</span><span class="n">transact</span><span class="o">(</span><span class="n">xa</span><span class="o">)</span>     <span class="c1">// IO[List[String]]
</span>  <span class="o">.</span><span class="n">unsafeRunSync</span>    <span class="c1">// List[String]
</span>  <span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span> <span class="c1">// Unit
// Afghanistan
// Netherlands
// Netherlands Antilles
// Albania
// Algeria
</span></code></pre>
</div>

<p>The difference here is that <code class="highlighter-rouge">stream</code> gives us an <a href="https://github.com/functional-streams-for-scala/fs2">fs2</a> <code class="highlighter-rouge">Stream[ConnectionIO, String]</code>
that emits rows as they arrive from the database. By applying <code class="highlighter-rouge">take(5)</code> we instruct the stream to shut everything down (and clean everything up) after five elements have been emitted. This is much more efficient than pulling all 239 rows and then throwing most of them away.</p>

<p>Of course a server-side <code class="highlighter-rouge">LIMIT</code> would be an even better way to do this (for databases that support it), but in cases where you need client-side filtering or other custom postprocessing, <code class="highlighter-rouge">Stream</code> is a very general and powerful tool.
For more information see the <a href="https://github.com/functional-streams-for-scala/fs2">fs2</a> repo, which has a good list of learning resources.</p>

<h3 id="yolo-mode">YOLO Mode</h3>

<p>The API we have seen so far is ok, but it’s tiresome to keep saying <code class="highlighter-rouge">transact(xa)</code> and doing <code class="highlighter-rouge">foreach(println)</code> to see what the results look like. So <strong>just for REPL exploration</strong> there is a module of extra syntax provided on your <code class="highlighter-rouge">Transactor</code> that you can import.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="n">xa</span><span class="o">.</span><span class="n">yolo</span> <span class="c1">// a stable reference is required
</span><span class="k">import</span> <span class="nn">y._</span>
</code></pre>
</div>

<p>We can now run our previous query in an abbreviated form.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="n">sql</span><span class="s">"select name from country"</span>
  <span class="o">.</span><span class="n">query</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="c1">// Query0[String]
</span>  <span class="o">.</span><span class="n">stream</span>        <span class="c1">// Stream[ConnectionIO, String]
</span>  <span class="o">.</span><span class="n">take</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>       <span class="c1">// Stream[ConnectionIO, String]
</span>  <span class="o">.</span><span class="n">quick</span>         <span class="c1">// IO[Unit]
</span>  <span class="o">.</span><span class="n">unsafeRunSync</span>
<span class="c1">//   Afghanistan
//   Netherlands
//   Netherlands Antilles
//   Albania
//   Algeria
</span></code></pre>
</div>

<p>This syntax allows you to quickly run a <code class="highlighter-rouge">Query0[A]</code> or <code class="highlighter-rouge">Stream[ConnectionIO, A]</code> and see the results printed to the console. This isn’t a huge deal but it can save you some keystrokes when you’re just messing around.</p>

<ul>
  <li>The <code class="highlighter-rouge">.quick</code> method sinks the stream to standard out (adding ANSI coloring for fun) and then calls <code class="highlighter-rouge">.transact</code>, yielding a <code class="highlighter-rouge">IO[Unit]</code>.</li>
  <li>The <code class="highlighter-rouge">.check</code> method returns a <code class="highlighter-rouge">IO[Unit]</code> that performs a metadata analysis on the provided query and asserted types and prints out a report. This is covered in detail in the chapter on typechecking queries.</li>
</ul>

<h3 id="multi-column-queries">Multi-Column Queries</h3>

<p>We can select multiple columns, of course, and map them to a tuple. The <code class="highlighter-rouge">gnp</code> column in our table is nullable so we’ll select that one into an <code class="highlighter-rouge">Option[Double]</code>. In a later chapter we’ll see how to check the types to be sure they’re sensible.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="n">sql</span><span class="s">"select code, name, population, gnp from country"</span>
  <span class="o">.</span><span class="n">query</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">String</span>, <span class="kt">Int</span>, <span class="kt">Option</span><span class="o">[</span><span class="kt">Double</span><span class="o">])]</span>
  <span class="o">.</span><span class="n">stream</span>
  <span class="o">.</span><span class="n">take</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
  <span class="o">.</span><span class="n">quick</span>
  <span class="o">.</span><span class="n">unsafeRunSync</span>
<span class="c1">//   (AFG,Afghanistan,22720000,Some(5976.0))
//   (NLD,Netherlands,15864000,Some(371362.0))
//   (ANT,Netherlands Antilles,217000,Some(1941.0))
//   (ALB,Albania,3401200,Some(3205.0))
//   (DZA,Algeria,31471000,Some(49982.0))
</span></code></pre>
</div>

<p><strong>doobie</strong> supports row mappings for atomic column types, as well as options, tuples, <code class="highlighter-rouge">HList</code>s, shapeless records, and case classes thereof. So let’s try the same query with an <code class="highlighter-rouge">HList</code>:</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">shapeless._</span>

<span class="n">sql</span><span class="s">"select code, name, population, gnp from country"</span>
  <span class="o">.</span><span class="n">query</span><span class="o">[</span><span class="kt">String</span> <span class="kt">::</span> <span class="kt">String</span> <span class="kt">::</span> <span class="kt">Int</span> <span class="kt">::</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">HNil</span><span class="o">]</span>
  <span class="o">.</span><span class="n">stream</span>
  <span class="o">.</span><span class="n">take</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
  <span class="o">.</span><span class="n">quick</span>
  <span class="o">.</span><span class="n">unsafeRunSync</span>
<span class="c1">//   AFG :: Afghanistan :: 22720000 :: Some(5976.0) :: HNil
//   NLD :: Netherlands :: 15864000 :: Some(371362.0) :: HNil
//   ANT :: Netherlands Antilles :: 217000 :: Some(1941.0) :: HNil
//   ALB :: Albania :: 3401200 :: Some(3205.0) :: HNil
//   DZA :: Algeria :: 31471000 :: Some(49982.0) :: HNil
</span></code></pre>
</div>

<p>And with a shapeless record:</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">shapeless.record.Record</span>

<span class="k">type</span> <span class="kt">Rec</span> <span class="o">=</span> <span class="nc">Record</span><span class="o">.</span><span class="n">`'code -&gt; String, 'name -&gt; String, 'pop -&gt; Int, 'gnp -&gt; Option[Double]`</span><span class="o">.</span><span class="n">T</span>

<span class="n">sql</span><span class="s">"select code, name, population, gnp from country"</span>
  <span class="o">.</span><span class="n">query</span><span class="o">[</span><span class="kt">Rec</span><span class="o">]</span>
  <span class="o">.</span><span class="n">stream</span>
  <span class="o">.</span><span class="n">take</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
  <span class="o">.</span><span class="n">quick</span>
  <span class="o">.</span><span class="n">unsafeRunSync</span>
<span class="c1">//   AFG :: Afghanistan :: 22720000 :: Some(5976.0) :: HNil
//   NLD :: Netherlands :: 15864000 :: Some(371362.0) :: HNil
//   ANT :: Netherlands Antilles :: 217000 :: Some(1941.0) :: HNil
//   ALB :: Albania :: 3401200 :: Some(3205.0) :: HNil
//   DZA :: Algeria :: 31471000 :: Some(49982.0) :: HNil
</span></code></pre>
</div>

<p>And again, mapping rows to a case class.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">Country</span><span class="o">(</span><span class="n">code</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">pop</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">gnp</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Double</span><span class="o">])</span>
</code></pre>
</div>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="n">sql</span><span class="s">"select code, name, population, gnp from country"</span>
  <span class="o">.</span><span class="n">query</span><span class="o">[</span><span class="kt">Country</span><span class="o">]</span>
  <span class="o">.</span><span class="n">stream</span>
  <span class="o">.</span><span class="n">take</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
  <span class="o">.</span><span class="n">quick</span>
  <span class="o">.</span><span class="n">unsafeRunSync</span>
<span class="c1">//   Country(AFG,Afghanistan,22720000,Some(5976.0))
//   Country(NLD,Netherlands,15864000,Some(371362.0))
//   Country(ANT,Netherlands Antilles,217000,Some(1941.0))
//   Country(ALB,Albania,3401200,Some(3205.0))
//   Country(DZA,Algeria,31471000,Some(49982.0))
</span></code></pre>
</div>

<p>You can also nest case classes, <code class="highlighter-rouge">HList</code>s, shapeless records, and/or tuples arbitrarily as long as the eventual members are of supported columns types. For instance, here we map the same set of columns to a tuple of two case classes:</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">Code</span><span class="o">(</span><span class="n">code</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Country2</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">pop</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">gnp</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Double</span><span class="o">])</span>
</code></pre>
</div>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="n">sql</span><span class="s">"select code, name, population, gnp from country"</span>
  <span class="o">.</span><span class="n">query</span><span class="o">[(</span><span class="kt">Code</span>, <span class="kt">Country2</span><span class="o">)]</span>
  <span class="o">.</span><span class="n">stream</span>
  <span class="o">.</span><span class="n">take</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
  <span class="o">.</span><span class="n">quick</span>
  <span class="o">.</span><span class="n">unsafeRunSync</span>
<span class="c1">//   (Code(AFG),Country2(Afghanistan,22720000,Some(5976.0)))
//   (Code(NLD),Country2(Netherlands,15864000,Some(371362.0)))
//   (Code(ANT),Country2(Netherlands Antilles,217000,Some(1941.0)))
//   (Code(ALB),Country2(Albania,3401200,Some(3205.0)))
//   (Code(DZA),Country2(Algeria,31471000,Some(49982.0)))
</span></code></pre>
</div>

<p>And just for fun, since the <code class="highlighter-rouge">Code</code> values are constructed from the primary key, let’s turn the results into a <code class="highlighter-rouge">Map</code>. Trivial but useful.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="n">sql</span><span class="s">"select code, name, population, gnp from country"</span>
  <span class="o">.</span><span class="n">query</span><span class="o">[(</span><span class="kt">Code</span>, <span class="kt">Country2</span><span class="o">)]</span>
  <span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">take</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
  <span class="o">.</span><span class="n">compile</span><span class="o">.</span><span class="n">toList</span>
  <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">toMap</span><span class="o">)</span>
  <span class="o">.</span><span class="n">quick</span>
  <span class="o">.</span><span class="n">unsafeRunSync</span>
<span class="c1">//   HashMap(Code(ANT) -&gt; Country2(Netherlands Antilles,217000,Some(1941.0)), Code(ALB) -&gt; Country2(Albania,3401200,Some(3205.0)), Code(DZA) -&gt; Country2(Algeria,31471000,Some(49982.0)), Code(NLD) -&gt; Country2(Netherlands,15864000,Some(371362.0)), Code(AFG) -&gt; Country2(Afghanistan,22720000,Some(5976.0)))
</span></code></pre>
</div>

<h3 id="final-streaming">Final Streaming</h3>

<p>In the examples above we construct a <code class="highlighter-rouge">Stream[ConnectionIO, A]</code> and discharge it via <code class="highlighter-rouge">.compile.toList</code>, yielding a <code class="highlighter-rouge">ConnectionIO[List[A]]</code> which eventually becomes a <code class="highlighter-rouge">IO[List[A]]</code>. So the construction and execution of the <code class="highlighter-rouge">Stream</code> is entirely internal to the <strong>doobie</strong> program.</p>

<p>However in some cases a stream is what we want as our “top level” type. For example, <a href="https://github.com/http4s/http4s">http4s</a> can use a <code class="highlighter-rouge">Stream[IO, A]</code> directly as a response type, which could allow us to stream a resultset directly to the network socket. We can achieve this in <strong>doobie</strong> by calling <code class="highlighter-rouge">transact</code> directly on the <code class="highlighter-rouge">Stream[ConnectionIO, A]</code>.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">val</span> <span class="n">p</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">Country2</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">sql</span><span class="s">"select name, population, gnp from country"</span>
    <span class="o">.</span><span class="n">query</span><span class="o">[</span><span class="kt">Country2</span><span class="o">]</span> <span class="c1">// Query0[Country2]
</span>    <span class="o">.</span><span class="n">stream</span>          <span class="c1">// Stream[ConnectionIO, Country2]
</span>    <span class="o">.</span><span class="n">transact</span><span class="o">(</span><span class="n">xa</span><span class="o">)</span>    <span class="c1">// Stream[IO, Country2]
</span><span class="o">}</span>
<span class="c1">// p: Stream[IO, Country2] = Stream(..)
</span>
<span class="n">p</span><span class="o">.</span><span class="n">take</span><span class="o">(</span><span class="mi">5</span><span class="o">).</span><span class="n">compile</span><span class="o">.</span><span class="n">toVector</span><span class="o">.</span><span class="n">unsafeRunSync</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">// Country2(Afghanistan,22720000,Some(5976.0))
// Country2(Netherlands,15864000,Some(371362.0))
// Country2(Netherlands Antilles,217000,Some(1941.0))
// Country2(Albania,3401200,Some(3205.0))
// Country2(Algeria,31471000,Some(49982.0))
</span></code></pre>
</div>

<h3 id="diving-deeper">Diving Deeper</h3>

<p>The <code class="highlighter-rouge">sql</code> interpolator is sugar for constructors defined in the <code class="highlighter-rouge">doobie.hi.connection</code> module, aliased as <code class="highlighter-rouge">HC</code> if you use the standard imports. Using these constructors directly, the above program would look like this:</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">val</span> <span class="n">proc</span> <span class="k">=</span> <span class="nc">HC</span><span class="o">.</span><span class="n">stream</span><span class="o">[(</span><span class="kt">Code</span>, <span class="kt">Country2</span><span class="o">)](</span>
  <span class="s">"select code, name, population, gnp from country"</span><span class="o">,</span> <span class="c1">// statement
</span>  <span class="o">().</span><span class="n">pure</span><span class="o">[</span><span class="kt">PreparedStatementIO</span><span class="o">],</span>                      <span class="c1">// prep (none)
</span>  <span class="mi">512</span>                                                <span class="c1">// chunk size
</span><span class="o">)</span>
<span class="c1">// proc: Stream[ConnectionIO, (Code, Country2)] = Stream(..)
</span>
<span class="n">proc</span><span class="o">.</span><span class="n">take</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>        <span class="c1">// Stream[ConnectionIO, (Code, Country2)]
</span>    <span class="o">.</span><span class="n">compile</span><span class="o">.</span><span class="n">toList</span> <span class="c1">// ConnectionIO[List[(Code, Country2)]]
</span>    <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">toMap</span><span class="o">)</span>   <span class="c1">// ConnectionIO[Map[Code, Country2]]
</span>    <span class="o">.</span><span class="n">quick</span>
    <span class="o">.</span><span class="n">unsafeRunSync</span>
<span class="c1">//   HashMap(Code(ANT) -&gt; Country2(Netherlands Antilles,217000,Some(1941.0)), Code(ALB) -&gt; Country2(Albania,3401200,Some(3205.0)), Code(DZA) -&gt; Country2(Algeria,31471000,Some(49982.0)), Code(NLD) -&gt; Country2(Netherlands,15864000,Some(371362.0)), Code(AFG) -&gt; Country2(Afghanistan,22720000,Some(5976.0)))
</span></code></pre>
</div>

<p>The <code class="highlighter-rouge">stream</code> combinator is parameterized on the element type and consumes a statement and a program in <code class="highlighter-rouge">PreparedStatementIO</code> that sets input parameters and any other pre-execution configuration. In this case the “prepare” program is a no-op.</p>
</section></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/doobie/highlight/highlight.pack.js"></script><script>hljs.configure({languages:['scala','java','bash']});
hljs.initHighlighting();
              </script><script src="/doobie/js/main.js"></script></body></html>